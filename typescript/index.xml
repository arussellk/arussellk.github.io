<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Typescript on rk</title><link>https://arussellk.github.io/typescript/</link><description>Recent content in Typescript on rk</description><generator>Hugo 0.125.1</generator><language>en</language><atom:link href="https://arussellk.github.io/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Exhaustive Switch</title><link>https://arussellk.github.io/typescript/exhaustive-switch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://arussellk.github.io/typescript/exhaustive-switch/</guid><description>Sometimes it is useful to have a compile-time check to make sure that all cases of a union are represented in code.
If the code in question is at a function boundary with a return type, you can get a compile-time check, but the error message is rather unclear. We can do better than this:
type Foo = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39; | &amp;#39;c&amp;#39;; const isSpecial = (foo: Foo): boolean =&amp;gt; { // ~~~~~~~ Function lacks ending return statement and return type does not include &amp;#39;undefined&amp;#39;.</description></item><item><title>Nominal Types</title><link>https://arussellk.github.io/typescript/nominal-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://arussellk.github.io/typescript/nominal-types/</guid><description>TypeScript uses structural subtyping. This means that any type that fits the shape of a different type is compatible. When using nominal types, on the other hand, two types are considered distinct and incompatible types even if they have the same underlying representation.
Here is a reasonably readable and usable way to have a form of nominal types in TypeScript:
type FooId = string &amp;amp; { __tag: &amp;#39;FooId&amp;#39; } type BarId = string &amp;amp; { __tag: &amp;#39;BarId&amp;#39; } const isFooId = (fooId: string): fooId is FooId =&amp;gt; /^[0-9a-f]{8}$/.</description></item><item><title>String Union Runtime Validation and Iteration</title><link>https://arussellk.github.io/typescript/string-union/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://arussellk.github.io/typescript/string-union/</guid><description>TypeScript types are removed by the compiler while producing JavaScript. This is fine much of the time within your system, but sometimes you need to validate user input or requests from external systems. One way to have both runtime validation and compile time types is to derive a string union type from an array.
const foos = [ &amp;#39;bar&amp;#39;, &amp;#39;baz&amp;#39;, ] as const type Foo = typeof foos[number] const isFoo = (x: string): x is Foo =&amp;gt; foos.</description></item></channel></rss>